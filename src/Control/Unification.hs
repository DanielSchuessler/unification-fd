
-- This is for the Show (MutTerm v t) instance
{-# LANGUAGE UndecidableInstances #-}

{-# LANGUAGE MultiParamTypeClasses, FlexibleInstances, FlexibleContexts #-}
{-# OPTIONS_GHC -Wall -fwarn-tabs #-}
----------------------------------------------------------------
--                                                  ~ 2011.06.30
-- |
-- Module      :  Control.Unification
-- Copyright   :  Copyright (c) 2007--2011 wren ng thornton
-- License     :  BSD
-- Maintainer  :  wren@community.haskell.org
-- Stability   :  experimental
-- Portability :  semi-portable (MPTCs, FlexibleInstances, FlexibleContexts)
--
-- This module defines ...
----------------------------------------------------------------
module Control.Unification
    (
    -- * Terms, and other ...
      MutTerm(..)
    , unfreeze
    , freeze
    , UnificationFailure(..)
    
    -- * Operations on one term
    , getFreeVars
    , applyBindings
    , freshen
    -- freezeM     -- apply bindings and freeze
    -- unskolemize -- convert Skolemized variables to free variables
    -- skolemize   -- convert free variables to Skolemized variables
    -- getSkolems  -- compute the skolem variables in a term; helpful?
    
    -- * Operations on two terms
    -- eqT         -- derived (==) @ (Fix f) given (Unifiable f)
    -- equals      -- (raw) equality under bindings
    -- equiv       -- alpha equivalence under bindings
    , unify1
    , unify2
    , unify3
    , unify4
    -- subsumes
    ) where

import Prelude
    hiding (mapM, mapM_, sequence, foldr, foldr1, foldl, foldl1, all, or)

import qualified Data.IntMap as IM
import qualified Data.IntSet as IS
import Data.Functor.Fixedpoint
import Data.Foldable
import Data.Traversable
import Control.Applicative
import Control.Monad.Trans (MonadTrans(..))
import Control.Monad.Error (MonadError(..), Error(..))
import Control.Monad.State (MonadState(..), evalStateT)
import Control.Monad.State.UnificationExtras
import Control.Unification.Classes
----------------------------------------------------------------
----------------------------------------------------------------

-- | The type of terms generated by structures @t@ over variables @v@.
data MutTerm v t
    = MutVar  !(v (MutTerm v t))
    | MutTerm !(t (MutTerm v t))

instance (Show (v (MutTerm v t)), Show (t (MutTerm v t))) =>
    Show (MutTerm v t)
    where
    show (MutVar  v) = show v
    show (MutTerm t) = show t


-- | /O(n)/. Embed a pure term as a mutable term.
unfreeze :: (Functor t) => Fix t -> MutTerm v t
unfreeze = MutTerm . fmap unfreeze . unFix


-- | /O(n)/. Extract a pure term from a mutable term, or return
-- @Nothing@ if the mutable term actually contains variables. N.B.,
-- this function is pure, so you should manually apply bindings
-- before calling it; cf., 'freezeM'.
freeze :: (Traversable t) => MutTerm v t -> Maybe (Fix t)
freeze (MutVar  _) = Nothing
freeze (MutTerm t) = Fix <$> mapM freeze t


----------------------------------------------------------------

-- TODO: use an ad-hoc coproduct of all these errors
-- TODO: provide zipper context so better error messages can be generated.
data UnificationFailure v t
    = OccursIn (v (MutTerm v t)) (MutTerm v t)
    | NonUnifiable (MutTerm v t) (MutTerm v t)
    | UnknownError String

-- Can't derive this... because it's an UndecidableInstance?
instance (Show (MutTerm v t), Show (v (MutTerm v t))) =>
    Show (UnificationFailure v t)
    where
    show (OccursIn     v  t)  = "OccursIn ("++show v++") ("++show t++")"
    show (NonUnifiable tl tr) = "NonUnifiable ("++show tl++") ("++show tr++")"
    show (UnknownError msg)   = "UnknownError: "++msg

-- This instance (and the constructor) is just for supporting MTL's 'ErrorT'.
instance Error (UnificationFailure v t) where
    noMsg  = UnknownError ""
    strMsg = UnknownError


----------------------------------------------------------------

-- TODO: add *weighted* path compression. Since this requires every
-- variable to have a mutable "rank" it'll be a rather invasive
-- change.


-- BUG: this assumes there are no directly-cyclic chains!
--
-- | Canonicalize a chain of mutable variables so they all point
-- directly to the term at the end of the chain (or the free variable,
-- if the chain is unbound), and return that end.
prune
    ::  ( BindingReader v (MutTerm v t) m
        , BindingWriter v (MutTerm v t) m
        )
    => MutTerm v t     -- ^
    -> m (MutTerm v t) -- ^
prune t0 =
    case t0 of
    MutTerm _ -> return t0
    MutVar  v -> do
        mb <- lookupVar v
        case mb of
            Nothing -> return t0
            Just t  -> do
                t' <- prune t
                v `bindVar_` t'
                return t'


-- | Determine if a mutable variable appears somewhere inside a term.
occursIn
    ::  ( Traversable t
        , BindingWriter v (MutTerm v t) m
        , BindingReader v (MutTerm v t) m
        )
    => v (MutTerm v t) -- ^
    -> MutTerm v t     -- ^
    -> m Bool          -- ^
occursIn v t0 = do
    t <- prune t0
    case t of
        MutTerm t' -> or <$> mapM (v `occursIn`) t'
        MutVar  v' -> return $! v `eqV` v'


-- BUG: this assumes there are no directly-cyclic chains!
--
-- | Canonicalize a chain of mutable variables so they all point
-- directly to the last variable in the chain, regardless of whether
-- it is bound or not. This allows detecting many cases where
-- multiple variables point to the same term, thereby allowing us
-- to avoid re-unifying the term they point to.
semiprune
    ::  ( BindingReader v (MutTerm v t) m
        , BindingWriter v (MutTerm v t) m
        )
    => MutTerm v t     -- ^
    -> m (MutTerm v t) -- ^
semiprune =
    \t0 ->
        case t0 of
        MutTerm _  -> return t0
        MutVar  v0 -> go t0 v0
    where
    -- We pass the @t@ for @v@ in order to add just a little more sharing.
    go t v = do
        mb <- lookupVar v
        case mb of
            Nothing -> return t
            Just t' -> 
                case t' of
                MutTerm _  -> return t
                MutVar  v' -> do
                    finalVar <- go t' v'
                    v `bindVar_` finalVar
                    return finalVar

----------------------------------------------------------------

-- TODO: these assume pure variables, hence the spine cloning; but
-- we may want to make variants for impure variables with explicit
-- rollback on backtracking.

-- TODO: See if MTL still has that overhead over doing things manually.

-- TODO: Figure out how to abstract the left-catamorphism from these.


-- | Walk a term and determine what variables are still free. N.B.,
-- this function does not detect cyclic terms, but it will return
-- the correct answer for them in finite time.
getFreeVars
    ::  ( Traversable t
        , BindingReader v (MutTerm v t) m
        , BindingWriter v (MutTerm v t) m -- for semiprune
        )
    => MutTerm v t         -- ^
    -> m [v (MutTerm v t)] -- ^
getFreeVars =
    \t -> IM.elems <$> evalStateT (go t) IS.empty
    where
    go t0 = do
        t1 <- lift $ semiprune t0
        case t1 of
            MutTerm t -> fold <$> mapM go t -- TODO: use foldlM instead?
            MutVar  v -> do
                seenVars <- get
                let i = getVarID v
                if IS.member i seenVars
                    then return IM.empty
                    else do
                        put $! IS.insert i seenVars
                        mb <- lift $ lookupVar v
                        case mb of
                            Just t' -> go t'
                            Nothing -> return $ IM.singleton i v


-- | Apply the current bindings from the monad so that any remaining
-- variables in the result must, therefore, be free. N.B., this
-- expensively clones term structure and should only be performed
-- when a pure term is needed. This function does preserve sharing,
-- however that sharing is no longer observed by @m@.
--
-- If any cyclic bindings are detected, then an 'OccursIn' exception
-- may be thrown.
applyBindings
    ::  ( Traversable t
        , BindingReader v (MutTerm v t) m
        , BindingWriter v (MutTerm v t) m -- for semiprune
        , MonadTrans e
        , Functor (e m) -- Monad (e m) should imply Functor damnit!
        , MonadError (UnificationFailure v t) (e m)
        )
    => MutTerm v t       -- ^
    -> e m (MutTerm v t) -- ^
applyBindings =
    \t -> evalStateT (go t) IM.empty
    where
    go t0 = do
        t1 <- lift . lift $ semiprune t0
        case t1 of
            MutTerm t -> MutTerm <$> mapM go t
            MutVar  v -> do
                let i = getVarID v
                mb <- IM.lookup i <$> get
                case mb of
                    Just (Right t) -> return t
                    Just (Left  t) -> lift . throwError $ OccursIn v t
                    Nothing -> do
                        mb' <- lift . lift $ lookupVar v
                        case mb' of
                            Nothing -> return t1
                            Just t  -> do
                                modify' . IM.insert i $ Left t
                                t' <- go t
                                modify' . IM.insert i $ Right t'
                                return t'


-- | Freshen all variables in a term, both bound and free. This
-- ensures that the observability of sharing is maintained, while
-- freshening the free variables. N.B., this expensively clones
-- term structure and should only be performed when necessary.
--
-- If any cyclic bindings are detected, then an 'OccursIn' exception
-- may be thrown.
freshen
    ::  ( Traversable t
        , BindingReader    v (MutTerm v t) m
        , BindingWriter    v (MutTerm v t) m -- for semiprune
        , BindingGenerator v (MutTerm v t) m
        , MonadTrans e
        , Functor (e m) -- Monad (e m) should imply Functor damnit!
        , MonadError (UnificationFailure v t) (e m)
        )
    => MutTerm v t       -- ^
    -> e m (MutTerm v t) -- ^
freshen =
    \t -> evalStateT (go t) IM.empty
    where
    go t0 = do
        t1 <- lift . lift $ semiprune t0
        case t1 of
            MutTerm t -> MutTerm <$> mapM go t
            MutVar  v -> do
                let i = getVarID v
                seenVars <- get
                case IM.lookup i seenVars of
                    Just (Right t) -> return t
                    Just (Left  t) -> lift . throwError $ OccursIn v t
                    Nothing -> do
                        mb <- lift . lift $ lookupVar v
                        case mb of
                            Nothing -> do
                                v' <- lift . lift $ MutVar <$> freeVar
                                put $ IM.insert i (Right v') seenVars
                                return v'
                            Just t  -> do
                                put $ IM.insert i (Left t) seenVars
                                t' <- go t
                                v' <- lift . lift $ MutVar <$> newVar t'
                                modify' $ IM.insert i (Right v')
                                return v'

----------------------------------------------------------------
----------------------------------------------------------------

acyclicBindVar_
    ::  ( Traversable t
        , BindingWriter v (MutTerm v t) m
        , BindingReader v (MutTerm v t) m
        , MonadTrans e
        , MonadError (UnificationFailure v t) (e m)
        )
    => v (MutTerm v t) -- ^
    -> MutTerm v t     -- ^
    -> e m ()          -- ^
acyclicBindVar_ v t = do
    b <- lift $ v `occursIn` t
    if b
        then throwError $ OccursIn v t
        else lift $ v `bindVar_` t


-- | A simple (yet relatively naive) implementation of unification.
-- Uses the occurs-check and full pruning. This is the same algorithm
-- presented by Sheard (2001), which is a Haskell version of the
-- implementation by Cardelli (1987).
--
--     * Tim Sheard (2001) /Generic Unification via Two-Level Types/
--         /and Parameterized Modules/, Functional Pearl, ICFP.
--
--     * Luca Cardelli (1987) /Basic polymorphic typechecking/.
--         Science of Computer Programming, 8(2):147--172.
unify1
    ::  ( Unifiable t
        , BindingWriter v (MutTerm v t) m
        , BindingReader v (MutTerm v t) m
        , MonadTrans e
        , MonadError (UnificationFailure v t) (e m)
        )
    => MutTerm v t -- ^
    -> MutTerm v t -- ^
    -> e m ()      -- ^
unify1 tl0 tr0 = do
    tl <- lift $ prune tl0
    tr <- lift $ prune tr0
    case (tl, tr) of
        -- N.B., because of full pruning, we know all MutVars here are unbound.
        (MutVar vl, MutVar vr)
            | vl `eqV` vr -> return ()
            | otherwise   -> lift $ vl `bindVar_` tr
        (MutVar vl, _)    -> vl `acyclicBindVar_` tr
        (_, MutVar vr)    -> vr `acyclicBindVar_` tl
        (MutTerm tl', MutTerm tr') ->
            case getMore $ match tl' tr' of
            Nothing    -> throwError $ NonUnifiable tl tr
            Just pairs -> mapM_ (uncurry unify1) pairs


-- | Extend 'unify1' with some observable sharing by using semipruning
-- instead of full pruning. Still uses the occurs check.
unify2
    ::  ( Unifiable t
        , BindingWriter v (MutTerm v t) m
        , BindingReader v (MutTerm v t) m
        , MonadTrans e
        , MonadError (UnificationFailure v t) (e m)
        )
    => MutTerm v t -- ^
    -> MutTerm v t -- ^
    -> e m ()      -- ^
unify2 tl0 tr0 = do
    tl <- lift $ semiprune tl0
    tr <- lift $ semiprune tr0
    case (tl, tr) of
        (MutVar vl, MutVar vr)
            | vl `eqV` vr -> return ()
            | otherwise   -> do
                mtl <- lift $ lookupVar vl
                mtr <- lift $ lookupVar vr
                case (mtl, mtr) of
                    (Nothing,  Nothing ) -> lift $ vl `bindVar_` tr
                    (Nothing,  Just tr') -> lift $ vl `bindVar_` tr'
                    (Just tl', Nothing ) -> lift $ vr `bindVar_` tl'
                    (Just tl', Just tr') -> do
                        unify2 tl' tr'
                        lift $ vl `bindVar_` tr
        
        (MutVar vl, _) -> do
            mtl <- lift $ lookupVar vl
            case mtl of
                Nothing  -> vl `acyclicBindVar_` tr
                Just tl' -> unify2 tl' tr
        
        (_, MutVar vr) -> do
            mtr <- lift $ lookupVar vr
            case mtr of
                Nothing  -> vr `acyclicBindVar_` tl
                Just tr' -> unify2 tl tr'
        
        (MutTerm tl', MutTerm tr') ->
            case getMore $ match tl' tr' of
            Nothing    -> throwError $ NonUnifiable tl tr
            Just pairs -> mapM_ (uncurry unify2) pairs


localState :: (MonadState s m) => m a -> m a
localState m = do
    s <- get
    x <- m
    put s
    return x
{-# INLINE localState #-}


-- TODO: Verify this is still correct
-- | Extend 'unify2' by using visited-sets instead of the occurs-check.
unify3
    ::  ( Unifiable t
        , BindingWriter v (MutTerm v t) m
        , BindingReader v (MutTerm v t) m
        , MonadTrans e
        , Functor (e m) -- Monad (e m) should imply Functor damnit!
        , MonadError (UnificationFailure v t) (e m)
        )
    => MutTerm v t -- ^
    -> MutTerm v t -- ^
    -> e m ()      -- ^
unify3 =
    \tl tr -> evalStateT (go tl tr) IM.empty
    where
    
    v =: t = lift . lift $ v `bindVar_` t
    {-# INLINE (=:) #-}
    
    v `seenAs` t = do
        mb <- IM.lookup (getVarID v) <$> get
        case mb of
            Just t' -> lift . throwError $ OccursIn v t'
            Nothing -> modify' $ IM.insert (getVarID v) t
    {-# INLINE seenAs #-}
    
    -- :: StateT VisitedSet (ErrorT UnificationFailure m) ()
    go tl0 tr0 = do
        tl1 <- lift . lift $ semiprune tl0
        tr1 <- lift . lift $ semiprune tr0
        case (tl1, tr1) of
            (MutVar vl, MutVar vr)
                | vl `eqV` vr -> return ()
                | otherwise   -> do
                    mtl <- lift . lift $ lookupVar vl
                    mtr <- lift . lift $ lookupVar vr
                    case (mtl, mtr) of
                        (Nothing,  Nothing ) -> vl =: tr1 -- or, vr =: tl1
                        (Nothing,  Just _  ) -> vl =: tr1
                        (Just _  , Nothing ) -> vr =: tl1
                        (Just tl', Just tr') -> do
                            localState $ do
                                vl `seenAs` tl'
                                vr `seenAs` tr'
                                go tl' tr'
                            vl =: tr1 -- or, vr =: tl1
            
            (MutVar vl, MutTerm _) -> do
                mtl <- lift . lift $ lookupVar vl
                case mtl of
                    Nothing  -> vl =: tr1
                    Just tl' -> localState $ do vl `seenAs` tl' ; go tl' tr1
            
            (MutTerm _, MutVar vr) -> do
                mtr <- lift . lift $ lookupVar vr
                case mtr of
                    Nothing  -> vr =: tl1
                    Just tr' -> localState $ do vr `seenAs` tr' ; go tl1 tr'
            
            (MutTerm tl', MutTerm tr') ->
                case getMore $ match tl' tr' of
                Nothing    -> lift . throwError $ NonUnifiable tl1 tr1
                Just pairs -> mapM_ (uncurry go) pairs


-- TODO: keep in sync with unify3
-- | A variant of 'unify3' which uses aggressive observable sharing.
unify4
    ::  ( Unifiable t
        , BindingWriter v (MutTerm v t) m
        , BindingReader v (MutTerm v t) m
        , MonadTrans e
        , Functor (e m) -- Monad (e m) should imply Functor damnit!
        , MonadError (UnificationFailure v t) (e m)
        )
    => MutTerm v t       -- ^
    -> MutTerm v t       -- ^
    -> e m (MutTerm v t) -- ^
unify4 =
    \tl tr -> evalStateT (go tl tr) IM.empty
    where
    
    v =: t = lift . lift $ v `bindVar_` t
    {-# INLINE (=:) #-}
    
    v `seenAs` t = do
        mb <- IM.lookup (getVarID v) <$> get
        case mb of
            Just t' -> lift . throwError $ OccursIn v t'
            Nothing -> modify' $ IM.insert (getVarID v) t
    {-# INLINE seenAs #-}
    
    go tl0 tr0 = do
        tl1 <- lift . lift $ semiprune tl0
        tr1 <- lift . lift $ semiprune tr0
        case (tl1, tr1) of
            (MutVar vl, MutVar vr)
                | vl `eqV` vr -> return tr1
                | otherwise   -> do
                    mtl <- lift . lift $ lookupVar vl
                    mtr <- lift . lift $ lookupVar vr
                    case (mtl, mtr) of
                        (Nothing,  Nothing ) -> do vl =: tr1 ; return tr1
                        (Nothing,  Just _  ) -> do vl =: tr1 ; return tr1
                        (Just _  , Nothing ) -> do vr =: tl1 ; return tl1
                        (Just tl', Just tr') -> do
                            tlr <- localState $ do
                                vl `seenAs` tl'
                                vr `seenAs` tr'
                                go tl' tr'
                            vr =: tlr
                            vl =: tr1
                            return tr1
            
            (MutVar vl, MutTerm _) -> do
                mtl <- lift . lift $ lookupVar vl
                case mtl of
                    Nothing  -> do vl =: tr1 ; return tl1
                    Just tl' -> do
                        tlr <- localState $ do
                            vl `seenAs` tl'
                            go tl' tr1
                        vl =: tlr
                        return tl1
            
            (MutTerm _, MutVar vr) -> do
                mtr <- lift . lift $ lookupVar vr
                case mtr of
                    Nothing  -> do vr =: tl1 ; return tr1
                    Just tr' -> do
                        tlr <- localState $ do
                            vr `seenAs` tr'
                            go tl1 tr'
                        vr =: tlr
                        return tr1
            
            (MutTerm tl', MutTerm tr') ->
                case zipMatch tl' tr' of
                Nothing  -> lift . throwError $ NonUnifiable tl1 tr1
                Just tlr -> MutTerm <$> mapM (uncurry go) tlr

----------------------------------------------------------------
----------------------------------------------------------- fin.
